// === Config ===
let LAT = 52.3676, LON = 4.9041;            // fallback (Amsterdam)
let TWILIGHT_MIN = 45;                      // min before sunrise / after sunset
let MIN_BRIGHT = 10, MAX_BRIGHT = 100;      // %
let PREDAWN_BRIGHT = 4, PULSE_BRIGHT = 10;  // %
let PULSE_MS = 100;                         // ms 'energize' pulse
let CYCLE_WINDOW_MS = 30 * 1000;            // 30s re-toggle window
let UPDATE_MS = 120 * 1000;                 // re-apply scaled brightness when ON

// === Deep night start (configurable) ===
let DEEP_NIGHT_START_H = 20; // 0..23
let DEEP_NIGHT_START_M = 0;  // 0..59

// === KVS keys ===
let KEY_IDX = "brightness_idx";
let KEY_WSTART = "brightness_window_start_ms";
let KEY_SIG = "brightness_sig"; // "DAY" | "NIGHT"

// === State ===
let idx = 0, windowStartMs = 0, lastSig = "";
let sunriseMs = 0, sunsetMs = 0, dayKey = "";
let lastOnIndex = -1;

// === Utils ===
let log = (m) => print("[CycleScript] " + m);
let ms = (m) => m * 60000;
let pad2 = (n) => (n < 10 ? "0" : "") + n;
let ymdKey = (d) => d.getFullYear() + "-" + pad2(d.getMonth() + 1) + "-" + pad2(d.getDate());
let between = (t, a, b) => t >= a && t < b;
let kExp = () => Math.log(MIN_BRIGHT / MAX_BRIGHT) / TWILIGHT_MIN;

function currentMode(nowMs) {
  if (!sunriseMs || !sunsetMs) return "DAY";
  return between(nowMs, sunriseMs, sunsetMs) ? "DAY" : "NIGHT";
}
function deepNightStartMs(d) {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate(), DEEP_NIGHT_START_H, DEEP_NIGHT_START_M, 0, 0).getTime();
}
let preDawnStartMs = () => sunriseMs - ms(TWILIGHT_MIN);

function isPreDawnDeepNight(nowMs) {
  if (!sunriseMs) return false;
  let now = new Date(nowMs);
  let start = deepNightStartMs(now);
  if (nowMs < start) start -= 24 * 60 * 60 * 1000;
  return between(nowMs, start, preDawnStartMs());
}

// === Serialized KVS writer ===
let kvsBatch = [], kvsPtr = 0, kvsInFlight = false;
function enqueueKVS(key, value) {
  for (let i = kvsPtr; i < kvsBatch.length; i++) if (kvsBatch[i].key === key) { kvsBatch[i].value = value; key = null; break; }
  if (key !== null) kvsBatch[kvsBatch.length] = { key, value };
  processKVSQueue();
}
function processKVSQueue() {
  if (kvsInFlight) return;
  if (kvsPtr >= kvsBatch.length) { kvsBatch = []; kvsPtr = 0; return; }
  kvsInFlight = true;
  let it = kvsBatch[kvsPtr];
  Shelly.call("KVS.Set", { key: it.key, value: it.value }, function () { kvsInFlight = false; kvsPtr++; processKVSQueue(); });
}

// === Location ===
function loadLatLon(cb) {
  Shelly.call("Sys.GetConfig", {}, function (res, ec) {
    if (!ec && res && res.location) {
      if (typeof res.location.lat === "number") LAT = res.location.lat;
      if (typeof res.location.lon === "number") LON = res.location.lon;
      log("Using lat=" + LAT + " lon=" + LON);
    } else log("Using fallback lat/lon=" + LAT + "/" + LON);
    cb && cb();
  });
}

// === Sunrise/Sunset ===
function fallbackTimes(now, today) {
  sunriseMs = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 7, 0, 0, 0).getTime();
  sunsetMs  = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 20, 0, 0, 0).getTime();
  dayKey = today;
}
function refreshSunTimes() {
  let now = new Date(), today = ymdKey(now);
  let url = "https://api.sunrise-sunset.org/json?lat=" + LAT + "&lng=" + LON + "&date=today&formatted=0";
  Shelly.call("HTTP.Request", { method: "GET", url, timeout: 10 }, function (r, ec) {
    if (ec || !r || r.code !== 200) { log("Sun API error; fallback times used"); return fallbackTimes(now, today); }
    try {
      let obj = JSON.parse(r.body), rs = obj && obj.results;
      if (!rs || !rs.sunrise || !rs.sunset) throw new Error("Missing sunrise/sunset");
      let sr = new Date(rs.sunrise), ss = new Date(rs.sunset);
      if (isNaN(sr.getTime()) || isNaN(ss.getTime())) throw new Error("Invalid date");
      sunriseMs = sr.getTime(); sunsetMs = ss.getTime(); dayKey = today;
      log("Fetched sunrise UTC " + pad2(sr.getHours()) + ":" + pad2(sr.getMinutes()) +
          " / sunset UTC " + pad2(ss.getHours()) + ":" + pad2(ss.getMinutes()));
    } catch (e) { log("Parse error: " + e + " ; using fallback times"); fallbackTimes(now, today); }
  });
}
function ensureFreshSunData() {
  let now = new Date(), todayKey = ymdKey(now);
  if (!sunriseMs || !sunsetMs || dayKey !== todayKey || now.getTime() > sunsetMs) refreshSunTimes();
}

// === Exponential scalers ===
function scaled(nowMs, refMs) {
  let dt = Math.abs(nowMs - refMs) / 60000;
  if (dt <= 0) return MAX_BRIGHT;
  if (dt >= TWILIGHT_MIN) return MIN_BRIGHT;
  return Math.round(MAX_BRIGHT * Math.exp(kExp() * dt));
}
let scaledAfterSunset  = (t) => (t <= sunsetMs) ? MAX_BRIGHT : scaled(t, sunsetMs);
let scaledBeforeSunrise = (t) => (t >= sunriseMs) ? MAX_BRIGHT : scaled(t, sunriseMs);

// === Levels ===
function getLevels() {
  ensureFreshSunData();
  let nowMs = Date.now();
  if (between(nowMs, sunriseMs, sunsetMs)) return [100, 50];
  if (between(nowMs, sunriseMs - ms(TWILIGHT_MIN), sunriseMs)) return [scaledBeforeSunrise(nowMs), 50, 100];
  if (between(nowMs, sunsetMs, sunsetMs + ms(TWILIGHT_MIN))) return [scaledAfterSunset(nowMs), 50, 100];
  if (isPreDawnDeepNight(nowMs)) return [PREDAWN_BRIGHT, 50, 100];
  return [MIN_BRIGHT, 50, 100];
}

// === KVS load (reads only) ===
function loadKVS() {
  Shelly.call("KVS.Get", { key: KEY_IDX }, function (r1) {
    let n = Number(r1 && r1.value); if (!isNaN(n)) idx = n;
    Shelly.call("KVS.Get", { key: KEY_WSTART }, function (r2) {
      let t = Number(r2 && r2.value); if (!isNaN(t)) windowStartMs = t;
      Shelly.call("KVS.Get", { key: KEY_SIG }, function (r3) {
        if (r3 && typeof r3.value !== "undefined") lastSig = String(r3.value);
        log("Boot: idx=" + idx + " windowStartMs=" + windowStartMs + " lastSig=" + lastSig);
      });
    });
  });
}
let saveIdx = () => enqueueKVS(KEY_IDX, idx);
function saveWindow(nowMs, sig) { windowStartMs = nowMs; lastSig = sig; enqueueKVS(KEY_WSTART, nowMs); enqueueKVS(KEY_SIG, sig); }

// === Light ===
let setLight = (on, brightness) => Shelly.call("Light.Set", { id: 0, on, brightness: brightness || 0, transition: 0 }, function () {});
let turnOnAt = (lvl) => { log("ON at " + lvl + "%"); setLight(true, lvl); };
let turnOffInstant = () => { log("OFF instantly"); setLight(false, 0); };

function turnOnPossiblyWithPulse(targetLevel, nowMs) {
  if (isPreDawnDeepNight(nowMs) && targetLevel === PREDAWN_BRIGHT) {
    log("Pre-dawn pulse: " + PULSE_BRIGHT + "% â†’ " + targetLevel + "% after " + PULSE_MS + "ms");
    setLight(true, PULSE_BRIGHT);
    Timer.set(PULSE_MS, false, function () { setLight(true, targetLevel); });
  } else turnOnAt(targetLevel);
}

// === Cycle logic ===
function clampIdx(levels) { idx = idx % levels.length; if (idx < 0) idx = 0; }
function shouldResetWindow(nowMs, sig) { return !((nowMs - windowStartMs) <= CYCLE_WINDOW_MS && sig === lastSig); }

// === Events ===
Shelly.addEventHandler(function (e) {
  if (e.component !== "input:0" || !e.info || e.info.event !== "toggle") return;
  let levels = getLevels(), nowMs = Date.now(), modeSig = currentMode(nowMs);
  if (e.info.state) { // ON
    if (shouldResetWindow(nowMs, modeSig)) { idx = 0; saveWindow(nowMs, modeSig); }
    clampIdx(levels);
    lastOnIndex = idx;
    turnOnPossiblyWithPulse(levels[idx], nowMs);
    idx = (idx + 1) % levels.length; // prepare next
    saveIdx();
  } else { // OFF
    turnOffInstant();
    lastOnIndex = -1;
  }
});

// === Periodic updater (only first level at NIGHT) ===
Timer.set(UPDATE_MS, true, function () {
  let nowMs = Date.now();
  if (currentMode(nowMs) !== "NIGHT" || lastOnIndex !== 0) return;
  Shelly.call("Light.GetStatus", { id: 0 }, function (res, ec) {
    if (ec || !res || !res.ison) return;
    let target = (nowMs < sunriseMs) ? scaledBeforeSunrise(nowMs) :
                 (nowMs >= sunsetMs) ? scaledAfterSunset(nowMs) : null;
    if (target == null) return;
    let cur = (typeof res.brightness === "number") ? Math.round(res.brightness) : null;
    if (cur == null || Math.abs(target - cur) >= 1) {
      log("Adjusting scaled brightness to " + target + "%");
      setLight(true, target);
    }
  });
});

// === Daily refresh at 00:10 (cron-free) ===
function msUntilNext(h, m, s) {
  let now = new Date();
  let next = new Date(now.getFullYear(), now.getMonth(), now.getDate(), h, m, s || 0, 0);
  if (next.getTime() <= now.getTime()) next = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, h, m, s || 0, 0);
  return next.getTime() - now.getTime();
}
(function scheduleDailyRefresh() {
  let delay = Math.max(1000, msUntilNext(0, 10, 0));
  Timer.set(delay, false, function () { refreshSunTimes(); scheduleDailyRefresh(); });
})();

// === Boot ===
loadKVS();
loadLatLon(refreshSunTimes);
